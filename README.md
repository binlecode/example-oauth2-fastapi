# A basic OAuth2 authorization server with FastAPI framework

This is a conceptual and simplified implementation of OAuth2 authorization
server with plain python, only for learning purpose.

A mature OAuth2 python library to use in implementing a production OAuth2
provider service is [authlib](https://github.com/lepture/authlib). It is
mainly sponsored by Auth0 and actively maintained.

A good java implementation tutorial is helpful to learn basic
OAuth2 concept is: https://www.baeldung.com/java-ee-oauth2-implementation.

Table of content:

- [A basic OAuth2 authorization server with FastAPI framework](#a-basic-oauth2-authorization-server-with-fastapi-framework)
  - [project setup](#project-setup)
  - [Dockerfile](#dockerfile)
  - [Project folder structure:](#project-folder-structure)
  - [OpenApi doc v3](#openapi-doc-v3)
  - [OpenApi v2 doc](#openapi-v2-doc)
  - [Pre-register client applications in database](#pre-register-client-applications-in-database)
  - [OAuth2 framework implementation](#oauth2-framework-implementation)
    - [federated IdP user authentication](#federated-idp-user-authentication)
    - [code grant](#code-grant)
      - [authorization code](#authorization-code)
    - [implicit grant](#implicit-grant)
    - [user password grant](#user-password-grant)
      - [user password hashing](#user-password-hashing)
    - [client credentials grant](#client-credentials-grant)
    - [token response](#token-response)
    - [OAuth2 access token and bearer token](#oauth2-access-token-and-bearer-token)
    - [self-encoded token encoding](#self-encoded-token-encoding)
    - [client application registration](#client-application-registration)
    - [client application redirect\_uri validation](#client-application-redirect_uri-validation)
    - [access token JWT signing and JWKS endpoint](#access-token-jwt-signing-and-jwks-endpoint)
  - [OAuth2 and OpenID connect](#oauth2-and-openid-connect)
    - [OAuth2 framework](#oauth2-framework)
  - [scratch pad](#scratch-pad)
  - [References](#references)

## project setup

FastAPI is ASGI framework, it supports sync ans async request handling seamlessly.
Think of FastAPI as the glue that brings together Starlette, Pydantic, OpenAPI,
and JSON Schema.

Use pyenv to select python version 3.10+

Python 3.10+ has better python type hint syntax and support, the type hint
is used by pydantic for data validation in fastapi web framework.

```sh
# optional: pip install ipython
pip install black
pip install fastapi
pip install sqlalchemy
# install uvicorn as ASGI server
pip install "uvicorn[standard]"
# install multipart support for form and file post
pip install python-multipart
# install cryptography lib python-jose for jwt
# JOSE stands for JavaScript Object Signing and Encryption
pip install "python-jose[cryptography]"
# install passlib for password hashing
# choose bcrypt as password hashing algorithm
# ref: https://en.wikipedia.org/wiki/Bcrypt
pip install "passlib[bcrypt]"
```

run app in development mode with reload enabled

```sh
uvicorn app.main:app --reload
# reset local sqlite db during app start up
RESET_DB=true uvicorn app.main:app --reload
```

By default,

- uvicorn web server listens at port 8000.
- OAuth2 provider endpoint url set to http://127.0.0.1:8000

To change port number, say, 8080:

```sh
OAUTH2_URL_BASE=http://127.0.0.1:8080 \
RESET_DB=true \
  uvicorn app.main:app --reload --port=8080
```

## Dockerfile

Build docker image and run container locally:

```sh
docker build -t example-oauth2-fastapi .
docker run --name example-oauth2-fastapi -p 8080:8080 --rm example-oauth2-fastapi
```

Google cloud build:

```sh
# gcloud builds --project <project-id> \
#   submit --tag gcr.io/<project-id>/<app-name>:<ver-or-tag> .

gcloud builds --project poc-data-platform-289915 \
    submit --tag gcr.io/poc-data-platform-289915/oauth2-fastapi:v1.0.5 .
->
... gcr.io/poc-data-platform-289915/oauth2-fastapi:v1.0.5  SUCCESS
```

Update [gke-deployment.yaml](./gke-deployment.yaml) manifest to use the 
latest gcr.io image tag, and deploy the workload:

```sh
kubectl apply -f gke-deployment.yaml
```

To exposethe workload, there are two options:

1. option1: expose workload with loadbalancer service
2. option2: expose workload with NodePort service + Ingress load balancer

Both options create an external load balancer with an external IP.
This external IP, by default, is dynamically generated by GCP, and is temporary.

For a more realistic deployment for an OAuth2 provider, a static external IP
is preferred.

To create a static IP:

```sh
gcloud compute addresses create oauth2-fastapi-static-ip --global

# check created
gcloud compute addresses list | grep oauth2-fastapi
->
oauth2-fastapi-static-ip   34.117.165.110  EXTERNAL RESERVED
```

With static ip enabled in ingress manifest, apply it:

```sh
kubectl apply -f gke-np-service-ingress-tls.yaml

kubectl get service | grep oauth2-fastapi
kubectl get ingress | grep oauth2-fastapi
->
oauth2-fastapi-ingress   <none>   *       34.117.165.110   80, 443   12m
```

To check in-cluster service access,
create a temp standalone pod, and test calling service via cluster DNS name.

```sh
kubectl run tmp-shell --rm -i --tty --restart=Never --image python:3.9 -- bin/bash

root@tmp-shell:/# curl http://oauth2-fastapi-service.default.svc.cluster.local:80/health
->
{"status":"up"}
```

Now, update application oauth2 endpoint url root with this created static
IP address. In [Dockerfile](./Dockerfile):

```Dockerfile
ENV OAUTH2_URL_BASE "http://34.117.165.110"
```

Rebuild image and redeploy the workload.

## Project folder structure:

```
Dockerfile           # container image
config.py            # application configrations
openapi_v2.yaml      # a static openapi v2 doc that can be loaded in swagger-ui
app                  # app root folder
├── __init__.py      # makes "app" a "Python package"
├── main.py          # "main" module of the application
├── models.py        # entity definitions
├── schemas.py       # pydantic schema models
├── security.py      # security utilites, such as encryption
├── db.py            # database impl
├── db_migration.py  # database migration scripts
└── routers          # "routers" is a "Python subpackage"
│   ├── __init__.py  # makes "routers" a "Python subpackage"
│   ├── commons.py   # web stack common utilities
│   ├── oauth2.py    # oauth2 provider endpoints
│   ├── oauth2_schemes.py   # oauth2 security scheme definitions
│   ├── idp.py       # a simple local IdP that provides user login
│   └── users.py     # "users" endpoints
```

## OpenApi doc v3

Openapi doc v3 is auto-generated by fastapi framework, and served at url:
http://127.0.0.1:8000/docs

With openapi doc loaded in swagger editor interface, it is recommended to use
it for interactive requests during development.

## OpenApi v2 doc

Also, an openapi v2 doc yaml file is available [openapi_v2.yaml](openapi_v2.yaml).
This yaml can be loaded to an online swagger-UI editor for testing.

An OAuth 2 client is pre-registered for the official swagger-ui (https://editor.swagger.io/).

## Pre-register client applications in database

For demo/testing, the database initial migration script includes the following
clients for token flows:

- local swagger UI client, via built-in openapi v3 '/docs' endpoint
- postman client
- online swagger editor client (https://editor.swagger.io/)

See [db_migration.py](app/db_migration.py) for detailed client registration
properties such as client credentials, redirect_uri, grant_types, token scopes,
etc. They will be used in swagger UI or postman authorization forms to invoke
authorization flows.

For example, for online-swagger client, paste the content of
[openapi_v2.yaml](openapi_v2.yaml) to https://editor.swagger.io.
To authorize with code grant flow, check client entity and user entity
specified in the database migration script and set:

- client_id=online-swagger
- client_secret=secret

And choose one of the two preloaded users, johndoe and alice, with his/her
respective password for authentication and token scope grant.

## OAuth2 framework implementation

OAuth 2 framework implies the collaboration between the four following roles:

- Resource Owner: Usually, this is the end-user – it's the entity that has some resources worth protecting
- Resource Server: An service that protects the resource owner's data, usually publishing it through a REST API
- Client: An application that uses the resource owner's data
- Authorization Server: An application that grants permission – or authority – to clients in the form of expiring tokens

A **grant type** is how a client gets permission to use the resource owner's data,
in the form of an access token.

Different types of clients prefer different types of grants:

- Authorization Code: Preferred most often – whether it is a web application,
  a native application, or a single-page application, though native and
  single-page apps require additional protection called PKCE.
  It's more secure thus preferred to use the authorization code grant with PKCE.
- Implicit grant: user is authenticated, authorized, and issued a token from
  the authorization endpoint directly.
- Client Credentials: Preferred for service-to-service communication, say when the resource owner isn't an end-user
- Resource Owner Password: Preferred for the first-party authentication of
  native applications, say when the mobile app needs its own login page
- Refresh Token: A special renewal grant, suitable for web applications to
  renew their existing token

Authorization code grant and implicit grant begin the flow with calling
the `/authorize` endpoint.

Client credential grant and password grant directly calls the `/token` endpoint.

Although password grant is defined as one of the grant flows in OAuth 2, it is
exactly why OAuth 2 is created to prevent in the first place.
Therefore, password grant should be discouraged or avoided.

In fact the password grant is being removed in OAuth 2.1 update.

### federated IdP user authentication

OAuth2 doesn't standardize user authentication.
The authorization server delegates the user authentication to an Identity
Provider (IdP). If the IdP is not local but a third party entity, this
becomes a federated user authentication.

The authorization endpoint redirects the user to be authenticated with
an IdP, if user is not authenticated yet.

Usually the IdP should have some sort of endpoint or web interface to
receive and validate user credentials. There are standard protocols designed
for this, such as OpenID connect and SAML.

In this example, an IdP with a web form user login interface is provided
in a different route path, to mimic a third party IdP. It can be from any
url or domain.

This delegated user authentication, aka a federated user identity retrieval,
is essentially a redirection flow, where the user-agent (web browser) serves
as the intermediary:
user is redirected to the IdP's authentication page, upon successful
authentication, user is redirected back to the authorization callback url,
where user approves the token grant, then redirected to the `redirect_uri`
from the original client application's request with the grant asset, which
is either an authorization code (code grant), or an access_token (implicit
grant).

The use of the user's web browser as an intermediary allows the
authorization server to receive the user's authentication response
from the IdP without needing to expose the user's credentials to the
client or the authorization server.
The redirect_uri in the original request is the callback endpoint
of the client application. In the use case of code grant, the client
application callback endpoint should handle the received authorization code
and POST to authorization server's /token endpoint to exchange for the
access token.

### code grant

Authorization Code Grant Flow:

1. An application, the client, requests permission by redirecting to the
   authorization server's `/authorize` endpoint. In calling this endpoint,
   the application sets `response_type=code`, and gives a callback url.
2. The authorization server will usually ask the end-user, the resource owner,
   for permission grant. If the end-user grants the permission, the authorization
   server redirects back to the callback url with an authorization code.
3. The application receives this code and then call the authorization server's
   `/token` endpoint, with the authorization code (granted by the end-user)
   along with client_id and client_secret (in BasicAuth header or POST form body).
   The authorization server responds with the access token after validating
   the authorization code.

With access token, the application makes its request to the API, the resource
server, and that API will verify the access token. It can ask the authorization
server to verify the token using its `/introspect` endpoint. Or, if the token is
self-contained, the resource server can optimize by locally verifying the
token's signature, as is the case with a JWT.

#### authorization code

The authorization code should be hard to guess or interpret. It must be short
lived, usually with a time window of a few minutes. To implement, the code
can be a self-contained token with expiration time encoded, so that it can be
checked when it is passed to authorization server in exchange for the access
token. This avoids the session state on the authorization server side to
track the code lifetime.

### implicit grant

The client application calls `/authorize` endpoint with `response_type=token`.
The authorization server responds with access token and redirect
the client application to the callback URL given in the request.

### user password grant

Password grant request calls `/token` endpoint to request token directly.

The access token request will contain the following parameters in POST body.

- grant_type (required) – The grant_type parameter must be set to “password”.
- username (required) – The user’s username.
- password (required) – The user’s password.
- scope (optional) – The scope requested by the application.
- Client Authentication (required if the client was issued a secret)

Client Authentication has two options for the client application to pass
the client_id and client_secret:

- basic auth header
- POST body form fields

#### user password hashing

Create hash string for a password before saving to database.

In python/ipython venv: run below script:

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
password = "secret"
hashed_password = pwd_context.hash(password)
```

### client credentials grant

Client credential grant request calls `/token` endpoint to request token.

- grant_type must be set to "client_credentials"
- scope (optional)
- Client Authentication required, passed in the request with two options
  same as password grant

### token response

The entire response is a JSON string.

Successful response:

- access_token
- token_type, usually "Bearer", meaning the access_token is a Bearer Token
- expires_in, optional but recommended, its the duration of time the access_token
  is valid for
- refresh_token, should be provided except for implicit grant
- scope, optional, if the scope the user granted is identical to the scope
  the client app requested, this parameter is optional. If the granted scope
  is different from the requested scope, such as if the user modified the scope,
  then this parameter is required in response
- id_token, optional, only provided if the request scope includes 'openid'
  is indeed granted by user, which means the client application is requesting
  for an id token besides the access token

Unsuccessful response:

- return http 400 bad request status code
- error: will always be one of the following:
  - invalid_request
  - invalid_client, 401 status code is preferred in this case
  - invalid_grant
  - invalid_scope
  - unauthorized_client
  - unsupported_grant_type
- error_description, optional message of the error

### OAuth2 access token and bearer token

OAuth2 access token is obtained by the client application to access the resource API.
It is issued by authorization server upon user （the resource owner） granted
permission. Access token is usually application specific, and can include
information about user and client application.

OAuth2 Bearer token is a type of access token. It is used to authenticate the
client application to the resource server. "Bearer" means it can be used by
any party who possesses it. Because of this, a bearer token does **not** contain
any information about the user or the client application, and it does **not**
include any encryption or digital signature to ensure their authenticity.
Instead, a bearer token relies on transport layer security to protect the
access to the resource server.

Comparing to access token, a bearer token is less specific and only include
information necessary to authenticate the client application in accessing
the resource server APIs.

### self-encoded token encoding

Self-encoded token avoid storing token in a database by encoding all necessary
information in the token string itself. It eliminates database lookup in every
resource API call, a huge performance benefit.

The most common way to implement self-encoded token is to use JWT, JSON Web
Token, which creates a JSON representation of all the data to include in the
token, and signs the resulting JSON string with a private key known only to
the authorization server.

Ref: OAuth 2 JWT access token specs:
https://oauth.net/2/jwt-access-tokens/

To decode the token, public key is needed that corresponds to the private key
used in signing the token.

Public key can be obtained from `/jwks` endpoint from the authorization server.

### client application registration

Authorization server is responsible for creating `client_id` and `client_secret`
when a new client application is being registered.

Not specified by OAuth2 specs, but typically the following information is
collected during client registration:

- client (application) name
- callback_uri (aka redirect_uri)
  - this can be a list or a comma-separated string to store multiple
    redirect_uri's, during the authorization flow the redirect_uri provided
    in the request should be checked against this list
- grant types: one or more grant types that this client can be authorized
  by resource owner
- scope: one or more token scopes that this client can be authorized by resource
  owner
- token endpoint auth methods: the methods that the token endpoint can use to
  authenticate the client, some common options are:
  - client_secret_basic: http basic auth header
  - client_secret_post: post body, either form or JSON
  - client_secret_jwt: openID connect jwt bearer token containing client secret
  - private_key_jwt: openID connect jwt bearer token containing private key
- homepage url
- a short description
- a link to application's privacy policy (can be used in consent approval)

### client application redirect_uri validation

The redirect_uri specifies where the users should be redirected after
they have chosen whether or not to authenticate the client application.

There are three cases where redirect_uri should be validated:

- when the developer registers the redirect URL as part of creating an application
- in the authorization request (both authorization code and implicit grant types)
- when the application exchanges an authorization code for an access token

### access token JWT signing and JWKS endpoint

By OAuth2 specs, authorization server should provide JSON Web Key (JWK)
Set (JWKS) endpoint for token-receiving parties to verify the issued JWT
token, specifically with RSA signing algorithm.
Two signing algorithms are commonly used in signing a JWT:

- RS256: stands for RS256+SHA256, RS256 is for signing, SHA256 is for hashing
  RS256 encrypts with an asymmetric key pair, which means a private key is used
  to sign the JWT and a public key must be used to verify the signature
  RS256 is usually preferred due to its asymmetric nature to support 3rd party
  (public) key sharing
- HS256: stands for HMAC+SHA256, HMAC is for signing
  HS256 encrypts with symmetric key, which means the JWT is signed and
  validated by the same key

For HS256 symmetric key signing, a simple random key can be generated with
openssl:

```sh
openssl rand -hex 32
09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
```

RS256 should be used in production system for OAuth 2 JWT signing, with its
public key being distributed via the JWKS endpoint, which is usually
"<auth-server-url-root>/.well-known/jwks.json".

To generate the key pair for JWT RS256 signing algorithm,
use `openssl` to generate RSA private key pem file:

```sh
openssl genpkey -algorithm RSA -out jwt-private-key.pem -pkeyopt rsa_keygen_bits:2048
```

```sh
openssl rsa -in jwt-private-key.pem -pubout -outform PEM -out jwt-public-key.pem
```

These two key files can be loaded in authorization server and used in
signing jwt tokens. However, this may not be sufficient when the key
pair is additionally required to be:

- rotated for certain period of time for enhanced security
- client specific for enhanced tenancy isolation

In such case, the key pair should be generated programmatically.
In Python, the [cryptography lib](https://cryptography.io/en/latest/) is
mostly used for RS256 key implementation.

```python
import json
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

# Generate RSA key pair
# `public_exponent` is a prime integer, which should be sufficiently large
# to make generated keys secure
# 65537 is what industry commonly uses to generate secure rs256 private keys
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)

# a private key can also be loaded from a pem file like the
# one generated above
src_private_key_pem = open("jwt-key").read()
private_key = serialization.load_pem_private_key(
    # serialization needs pem content to be in utf-8 format
    src_private_key_pem.encode("utf-8"),
    password=None,
    backend=default_backend()
)
public_key = private_key.public_key()

private_key_pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.TraditionalOpenSSL,
    encryption_algorithm=serialization.NoEncryption()
)

assert private_key_pem == src_private_key_pem.encode("utf-8")

public_key_pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

# key-id key for jwk
kid = "mykey"
# usage key for jwk, "sig" means for signing/signature
use = "sig"
n = public_key.public_numbers().n

# in the jwk above, the n (integer) is too long to be included in json
# so it is typically encoded to a url-safe base64 string
import base64

n_bytes = n.to_bytes((n.bit_length() + 7) // 8, byteorder='big')
n_b64 = base64.urlsafe_b64encode(n_bytes)

# to serialize it to json string, it needs to be converted to utf-8 string
n_b64_str = n_b64.decode("utf-8")

jwk = {
    "kty": "RSA",
    "kid": kid,
    "use": use,
    "alg": "RS256",
    "n": n_b64_str,
    "e": public_key.public_numbers().e,
}

jwks = {
    "keys": [jwk]
}

jwks_json = json.dumps(jwks)

# To use jwks json for jwt validation:
# first, extract public key from jwk
import base64

pub_key = None
for jwk in jwks["keys"]:
    if jwk["kid"] == kid:
        jwk_n = jwk["n"]
        n = None
        e = None
        if isinstance(jwk_n, str):
            n = int.from_bytes(base64.urlsafe_b64decode(jwk['n'] + "=="), byteorder='big')
        e = jwk["e"]
        if n and e:
            #
            pub_key = rsa.RSAPublicNumbers(e=e, n=n).public_key()
            break

if pub_key is None:
    raise Exception("Public key for kid not found")

pub_key_pem = pub_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

# the jwk extracted pub_key pem byte array should match its source byte array
assert public_key_pem == pub_key_pem

# then: Verify JWT signature using public key
from jose import jwt, JWTError

jwt_str = "<JWT string to validate>"
try:
    decoded = jwt.decode(jwt_str, key=pub_key_pem, algorithms=["RS256"])
except JWTError as e:
    print(e)
```

## OAuth2 and OpenID connect

OAuth 2 only defines authorization specs, leaves authentication up to the
identity provider (IdP). This potential gap of authentication **protocol**
standardization is filled by OpenID Connect.

Besides authorization, OAuth 2 framework can also be used to build authentication
and identity protocol:

- authorization server can provide an endpoint for user information, which
  usually takes the `/userinfo` uri.
- define scopes dedicated for user identify and information, `openid`, `profile`, etc

OpenID Connect protocol can be used to carry user id and other information
between enterprise entities. The core of OpenID Connect is a user **ID token**.

In contrast to access tokens, which are only intended to be understood by the
resource server, ID tokens are intended to be understood by the OAuth client.
When the client makes an OpenID Connect request, it can request an ID token
along with an access token.

OpenID Connect’s ID Tokens take the form of a JWT (JSON Web Token).
Inside the JWT are a handful of defined property names that provide information
to the application:

- sub: subject, identity of the resource owner
- iss: issuer, the server that issues the id token
- aud: audience, identity of the client that requests the id token
- exp: expiration time of the id token
- iat: issued at, the time the token is issued

When OAuth request contains `openid` scope, the above properties should
be present in returned access token.

### OAuth2 framework

## scratch pad

```sh
curl -X 'POST' \
  'http://127.0.0.1:8000/oauth2/userinfo' \
  -H 'X-Token: a-secret-token-123'  \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d {}
```

## References
